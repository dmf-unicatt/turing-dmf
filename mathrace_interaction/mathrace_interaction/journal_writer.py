# Copyright (C) 2024-2026 by the Turing @ DMF authors
#
# This file is part of Turing @ DMF.
#
# SPDX-License-Identifier: AGPL-3.0-or-later
"""Write a turing dictionary into a mathrace journal."""

import argparse
import datetime
import json
import sys
import typing

from mathrace_interaction.abc.abstract_journal_writer import AbstractJournalWriter
from mathrace_interaction.journal_reader import (
    JournalReaderR5539, JournalReaderR11167, JournalReaderR17505, JournalReaderR17548, JournalReaderR20642)
from mathrace_interaction.list_journal_versions import list_journal_versions
from mathrace_interaction.typing import TuringDict


class JournalWriterR5539(AbstractJournalWriter):
    """
    A class representing a writer of a mathrace journal, version r5539.

    Parameters
    ----------
    journal_stream
        The I/O stream that writes the journal to be read by mathrace or simdis.
        The I/O stream is typically generated by open().

    Attributes
    ----------
    strict_timestamp_race_events
        Strict processing of timestamp for race events. This should only be disabled when reading in
        journals generated by mathrace_interaction itself since it disables verification that race
        events are correctly sorted.
    """

    # Race setup codes
    RACE_DEFINITION = JournalReaderR5539.RACE_DEFINITION
    QUESTION_DEFINITION = JournalReaderR5539.QUESTION_DEFINITION

    # Race event codes
    RACE_START = JournalReaderR5539.RACE_START
    JOLLY_SELECTION = JournalReaderR5539.JOLLY_SELECTION
    ANSWER_SUBMISSION = JournalReaderR5539.ANSWER_SUBMISSION
    RACE_END = JournalReaderR5539.RACE_END
    MANUAL_BONUS = JournalReaderR5539.MANUAL_BONUS

    def __init__(self, journal_stream: typing.TextIO) -> None:
        super().__init__(journal_stream)
        # Strict processing of timestamp for race events
        self.strict_timestamp_race_events = True

    def _write_race_definition_section(self, turing_dict: TuringDict) -> None:
        """Write the race definition section."""
        line = self._store_race_definition_line("", turing_dict)
        self._write_line(line)

    def _store_race_definition_line(self, line: str, turing_dict: TuringDict) -> str:
        """Store the race definition line."""
        # Store the code
        assert line == ""
        line = f"--- {self.RACE_DEFINITION}"

        # This format contains a human readable comment at the end of the line
        comment = ""

        # Store the participating teams as the first entry
        line, comment = self._store_race_definition_num_teams_entry(line, comment, turing_dict)

        # Store the number of questions as the second entry
        line, comment = self._store_race_definition_num_questions_entry(line, comment, turing_dict)

        # Store the initial score as the third entry
        line = self._store_race_definition_initial_score_entry(line, turing_dict)

        # Store the bonus cardinality as the fourth entry
        line = self._store_race_definition_bonus_cardinality_entry(line, turing_dict)

        # Store the superbonus cardinality as the fifth entry
        line = self._store_race_definition_superbonus_cardinality_entry(line, turing_dict)

        # Store the value of n and k as the sixth entry
        line = self._store_race_definition_n_k_blocco_entry(line, turing_dict)

        # Store the value of the alternative k parameter as the seventh entry
        line = self._store_race_definition_alternative_k_blocco_entry(line, turing_dict)

        # Store the value of the race type as the eighth entry
        line = self._store_race_definition_race_type_entry(line, turing_dict)

        # Store the total time of the race as the ninth entry
        line = self._store_race_definition_total_time_entry(line, turing_dict)

        # Store the deadline time for question score periodic increase as the tenth entry
        line = self._store_race_definition_deadline_score_increase_entry(line, turing_dict)

        # Return line with comment appended at the end
        return f"{line} -- {comment}"

    def _store_race_definition_num_teams_entry(
        self, line: str, comment: str, turing_dict: TuringDict
    ) -> tuple[str, str]:
        """Store the number of teams entry in the race definition line."""
        assert comment == ""
        num_teams = len(turing_dict["squadre"])
        return f"{line} {num_teams}", f"squadre: {num_teams}"

    def _store_race_definition_num_questions_entry(
        self, line: str, comment: str, turing_dict: TuringDict
    ) -> tuple[str, str]:
        """Store the number of questions entry in the race definition line."""
        num_questions = turing_dict["num_problemi"]
        return f"{line} {num_questions}", f"{comment} quesiti: {num_questions}"

    def _store_race_definition_initial_score_entry(self, line: str, turing_dict: TuringDict) -> str:
        """Store the initial score entry in the race definition line."""
        return f'{line} {int(turing_dict["num_problemi"]) * 10}'

    def _store_race_definition_bonus_cardinality_entry(self, line: str, turing_dict: TuringDict) -> str:
        """Store the bonus cardinality entry in the race definition line."""
        return f'{line} {len(turing_dict["fixed_bonus"].split(","))}'

    def _store_race_definition_superbonus_cardinality_entry(self, line: str, turing_dict: TuringDict) -> str:
        """Store the superbonus cardinality entry in the race definition line."""
        return f'{line} {len(turing_dict["super_mega_bonus"].split(","))}'

    def _store_race_definition_n_k_blocco_entry(self, line: str, turing_dict: TuringDict) -> str:
        """Store the value of n in the race definition line."""
        if turing_dict["k_blocco"] == 1:
            return f'{line} {turing_dict["n_blocco"]}'
        else:
            raise RuntimeError("This version does not support a value of k_blocco different from one")

    def _store_race_definition_alternative_k_blocco_entry(self, line: str, turing_dict: TuringDict) -> str:
        """
        Store the alternative k parameter entry in the race definition line.

        Turing harcodes this value to 1.
        """
        return f"{line} 1"

    def _store_race_definition_race_type_entry(self, line: str, turing_dict: TuringDict) -> str:
        """
        Store the race type entry in the race definition line.

        mathrace hardcodes this value 1.
        """
        return f"{line} 1"

    def _store_race_definition_total_time_entry(self, line: str, turing_dict: TuringDict) -> str:
        """Store the total time of the race in the race definition line."""
        return f'{line} {turing_dict["durata"]}'

    def _store_race_definition_deadline_score_increase_entry(self, line: str, turing_dict: TuringDict) -> str:
        """Store the deadline time for question score periodic increase in the race definition line."""
        return f'{line} {turing_dict["durata"] - turing_dict["durata_blocco"]}'

    def _write_questions_definition_section(self, turing_dict: TuringDict) -> None:
        """Write the questions definition section."""
        # Do a consistency check first
        if int(turing_dict["num_problemi"]) != len(turing_dict["soluzioni"]):
            raise RuntimeError(
                "Inconsistent data in turing dictionary: "
                f'{int(turing_dict["num_problemi"])} != {len(turing_dict["soluzioni"])}')
        # Process each question
        for question_id in range(int(turing_dict["num_problemi"])):
            line = f"--- {self.QUESTION_DEFINITION}"
            line = self._store_question_definition_line(line, turing_dict, question_id)
            self._write_line(line)

    def _store_question_definition_line(self, line: str, turing_dict: TuringDict, question_id: int) -> str:
        """Store a question definition line."""
        question = turing_dict["soluzioni"][question_id]
        question_id_str = question["problema"]
        question_score = question["punteggio"]
        return (
            f"{line} {question_id_str} {question_score} "
            f"quesito {question_id_str} punteggio iniziale {question_score}"
        )

    def _write_teams_definition_section(self, turing_dict: TuringDict) -> None:
        """Write the teams definition section."""
        # This format does not really have a teams definition section, so don't do anything
        pass

    def _write_race_events_section(self, turing_dict: TuringDict) -> None:
        """Write all race events."""
        # Write the race start event first
        line = ""
        line = self._store_race_start_line(line, turing_dict)
        self._write_line(line)
        # Write race events from turing
        for event_id in range(len(turing_dict["eventi"])):
            line = ""
            line = self._store_race_event_line(line, turing_dict, event_id)
            self._write_line(line)
        # Write the race end event as the final event
        line = ""
        line = self._store_race_end_event(line, turing_dict)
        self._write_line(line)

    def _store_race_event_line(self, line: str, turing_dict: TuringDict, event_id: int) -> str:
        """Store a race event line."""
        event = turing_dict["eventi"][event_id]
        if event["subclass"] == "Jolly":
            return self._store_jolly_selection_event(line, turing_dict, event_id)
        elif event["subclass"] == "Consegna":
            return self._store_answer_submission_event(line, turing_dict, event_id)
        elif event["subclass"] == "Bonus":
            return self._store_manual_bonus_event(line, turing_dict, event_id)
        else:
            raise RuntimeError(f'Unhandled event type {event["subclass"]}')

    def _store_race_start_line(self, line: str, turing_dict: TuringDict) -> str:
        """Store the race start event."""
        assert line == ""
        race_start_timestamp = self._convert_datetime_to_timestamp(
            turing_dict["inizio"], self.strict_timestamp_race_events, turing_dict)
        return f"{race_start_timestamp} {self.RACE_START} inizio gara"

    def _store_jolly_selection_event(self, line: str, turing_dict: TuringDict, event_id: int) -> str:
        """Store a jolly selection event."""
        assert line == ""
        event = turing_dict["eventi"][event_id]
        event_timestamp = self._convert_datetime_to_timestamp(
            event["orario"], self.strict_timestamp_race_events, turing_dict)
        team_id = event["squadra_id"]
        question_id = event["problema"]
        event_mathrace_id = self._determine_mathrace_event_id(event_id)
        line = f"{event_timestamp} {self.JOLLY_SELECTION} {team_id} {question_id}"
        if int(event_mathrace_id) >= 0:
            line = f"{line} PROT:{event_mathrace_id}"
        return f"{line} squadra {team_id} sceglie {question_id} come jolly"

    def _store_answer_submission_event(self, line: str, turing_dict: TuringDict, event_id: int) -> str:
        """Store an answer submission event."""
        assert line == ""
        event = turing_dict["eventi"][event_id]
        event_timestamp = self._convert_datetime_to_timestamp(
            event["orario"], self.strict_timestamp_race_events, turing_dict)
        team_id = event["squadra_id"]
        question_id = event["problema"]
        correct_answer = event["risposta"] == turing_dict["soluzioni"][int(question_id) - 1]["risposta"]
        event_mathrace_id = self._determine_mathrace_event_id(event_id)
        line = f"{event_timestamp} {self.ANSWER_SUBMISSION} {team_id} {question_id} {int(correct_answer)}"
        if int(event_mathrace_id) >= 0:
            line = f"{line} PROT:{event_mathrace_id}"
        return f'{line} squadra {team_id}, quesito {question_id}: {"giusto" if correct_answer else "sbagliato"}'

    def _store_manual_bonus_event(self, line: str, turing_dict: TuringDict, event_id: int) -> str:
        """Store a manual bonus event."""
        assert line == ""
        event = turing_dict["eventi"][event_id]
        event_timestamp = self._convert_datetime_to_timestamp(
            event["orario"], self.strict_timestamp_race_events, turing_dict)
        team_id = event["squadra_id"]
        bonus_points = event["punteggio"]
        line = f"{event_timestamp} {self.MANUAL_BONUS} {team_id} {bonus_points}"
        return f"{line} squadra {team_id} bonus {bonus_points}"

    def _store_race_end_event(self, line: str, turing_dict: TuringDict) -> str:
        """Store the race end event."""
        assert line == ""
        race_start = datetime.datetime.fromisoformat(turing_dict["inizio"])
        total_time = datetime.timedelta(minutes=turing_dict["durata"])
        race_end = race_start + total_time
        if self._last_event_datetime is not None:
            race_end = max(race_end, self._last_event_datetime)
        race_end_timestamp = self._convert_datetime_to_timestamp(
            race_end.isoformat(), self.strict_timestamp_race_events, turing_dict)
        return f"{race_end_timestamp} {self.RACE_END} termine gara"

    def _convert_datetime_to_timestamp(self, datetime_str: str, strict: bool, turing_dict: TuringDict) -> str:
        """
        Convert a date and time into a timestamp.

        This version defines the timestamp as the number of elapsed seconds from the start of the race.
        """
        race_start = datetime.datetime.fromisoformat(turing_dict["inizio"])
        event = datetime.datetime.fromisoformat(datetime_str)
        self._update_last_event_datetime_and_check_events_correctly_sorted(event, strict)
        return str((event - race_start).seconds)

    def _update_last_event_datetime_and_check_events_correctly_sorted(
        self, event_datetime: datetime.datetime, strict: bool
    ) -> None:
        """Update the attribute storing the last event time and, if strict mode is on, ensure correct order."""
        assert self._last_event_datetime is not None
        if strict and event_datetime < self._last_event_datetime:
            raise RuntimeError(
                f"The file contains incorrectly sorted events: event at time {self._last_event_datetime} "
                f"happens before event at time {event_datetime}")
        self._last_event_datetime = event_datetime

    def _determine_mathrace_event_id(self, event_id: int) -> str:
        """Determine mathrace event ID. This version does not store them, so a placeholder is returned."""
        return "-1"


class JournalWriterR11167(JournalWriterR5539):
    """
    A class representing a writer of a mathrace journal, version r11167.

    This version introduced some code changes in race events

    Parameters
    ----------
    journal_stream
        The I/O stream that writes the journal to be read by mathrace or simdis.
        The I/O stream is typically generated by open().
    """

    # Race event codes
    RACE_START = JournalReaderR11167.RACE_START
    JOLLY_SELECTION = JournalReaderR11167.JOLLY_SELECTION
    ANSWER_SUBMISSION = JournalReaderR11167.ANSWER_SUBMISSION
    RACE_END = JournalReaderR11167.RACE_END
    MANUAL_BONUS = JournalReaderR11167.MANUAL_BONUS


class JournalWriterR11184(JournalWriterR11167):
    """
    A class representing a writer of a mathrace journal, version r11184.

    This version introduced protocol numbers in some race events.

    Parameters
    ----------
    journal_stream
        The I/O stream that writes the journal to be read by mathrace or simdis.
        The I/O stream is typically generated by open().
    """

    def __init__(self, journal_stream: typing.TextIO) -> None:
        super().__init__(journal_stream)
        self._last_mathrace_event_id = 0

    def _write_race_events_section(self, turing_dict: TuringDict) -> None:
        self._last_mathrace_event_id = 0
        super()._write_race_events_section(turing_dict)

    def _determine_mathrace_event_id(self, event_id: int) -> str:
        """Increment the last event ID in mathrace and return the current ID."""
        self._last_mathrace_event_id += 1
        return str(self._last_mathrace_event_id)


class JournalWriterR11189(JournalWriterR11184):
    """
    A class representing a writer of a mathrace journal, version r11189.

    This version added a further timer event. However, the change is not relevant for exporting from turing.

    Parameters
    ----------
    journal_stream
        The I/O stream that writes the journal to be read by mathrace or simdis.
        The I/O stream is typically generated by open().
    """


class JournalWriterR17497(JournalWriterR11189):
    """
    A class representing a writer of a mathrace journal, version r17497.

    This version added support for non-default k.

    Parameters
    ----------
    journal_stream
        The I/O stream that writes the journal to be read by mathrace or simdis.
        The I/O stream is typically generated by open().
    """

    def _store_race_definition_n_k_blocco_entry(self, line: str, turing_dict: TuringDict) -> str:
        """Store the value of n and k in the race definition line."""
        return f'{line} {turing_dict["n_blocco"]}.{turing_dict["k_blocco"]}'


class JournalWriterR17505(JournalWriterR17497):
    """
    A class representing a writer of a mathrace journal, version r17505.

    This version added team definition as a race code.

    Parameters
    ----------
    journal_stream
        The I/O stream that writes the journal to be read by mathrace or simdis.
        The I/O stream is typically generated by open().
    """

    # Race setup codes
    TEAM_DEFINITION = JournalReaderR17505.TEAM_DEFINITION
    """: str: The race setup code associated to the definition of a team."""

    def _write_teams_definition_section(self, turing_dict: TuringDict) -> None:
        """Write the teams definition section."""
        for team in turing_dict["squadre"]:
            line = f'--- {self.TEAM_DEFINITION} {team["num"]} {int(team["ospite"])} {team["nome"]}'
            self._write_line(line)


class JournalWriterR17548(JournalWriterR17505):
    """
    A class representing a writer of a mathrace journal, version r17548.

    This version added an alternative race definition.

    Parameters
    ----------
    journal_stream
        The I/O stream that writes the journal to be read by mathrace or simdis.
        The I/O stream is typically generated by open().
    """

    # Race setup codes
    RACE_DEFINITION_ALTERNATIVE = JournalReaderR17548.RACE_DEFINITION_ALTERNATIVE
    """: str: The race setup code associated to the alternative race definition."""

    def _store_race_definition_line(self, line: str, turing_dict: TuringDict) -> str:
        """Store the race definition line, include the alternative race definition."""
        # Store the code
        assert line == ""
        line = f"--- {self.RACE_DEFINITION_ALTERNATIVE}"

        # This format contains a human readable comment at the end of the line
        comment = ""

        # Store the participating teams as the first entry. This also includes the initial score
        line, comment = self._store_alternative_race_definition_num_teams_entry(line, comment, turing_dict)

        # Store the number of questions as the second entry
        line, comment = self._store_alternative_race_definition_num_questions_entry(line, comment, turing_dict)

        # Store the value of n, k and alternative k as the third entry
        line = self._store_alternative_race_definition_n_k_altk_blocco_entry(line, turing_dict)

        # Store the total time of the race, and the deadline time for question score periodic increase,
        # as the fourth entry
        line = self._store_alternative_race_definition_total_time_deadline_score_increase_entry(line, turing_dict)

        # Return line with comment appended at the end
        return f"{line} -- {comment}"

    def _store_alternative_race_definition_num_teams_entry(
        self, line: str, comment: str, turing_dict: TuringDict
    ) -> tuple[str, str]:
        """Store the number of teams entry in the alternative race definition line."""
        teams = turing_dict["squadre"]
        num_teams = len(teams)
        num_teams_nonguests = sum(not teams[s]["ospite"] for s in range(num_teams))
        num_teams_guests = sum(teams[s]["ospite"] for s in range(num_teams))
        initial_score = int(turing_dict["num_problemi"]) * 10
        return f"{line} {num_teams_nonguests}+{num_teams_guests}:{initial_score}", f"squadre: {num_teams}"

    def _store_alternative_race_definition_num_questions_entry(
        self, line: str, comment: str, turing_dict: TuringDict
    ) -> tuple[str, str]:
        """
        Store the number of questions entry in the alternative race definition line.

        Note that we cannot determine the actual default score from turing, so we will write out the conventional
        value equal to 20. However, that value will never be used in practice, because all questions (alongside
        their score) will surely be written out in the questions definition section.
        """
        num_questions = turing_dict["num_problemi"]
        return f"{line} {num_questions}:20", f"{comment} quesiti: {num_questions}"

    def _store_alternative_race_definition_n_k_altk_blocco_entry(self, line: str, turing_dict: TuringDict) -> str:
        """
        Store the value of n, k and alternative k in the alternative race definition line.

        Note that we cannot determine the actual value of alternative k from turing. However, the only choice
        which is compatibile with turing is the value 1, so we will hardcode this value.
        """
        return f'{line} {turing_dict["n_blocco"]}.{turing_dict["k_blocco"]};1'

    def _store_alternative_race_definition_total_time_deadline_score_increase_entry(
        self, line: str, turing_dict: TuringDict
    ) -> str:
        """Store the total time of the race and the deadline for score increase in the race definition line."""
        return f'{line} {turing_dict["durata"]}-{turing_dict["durata_blocco"]}'


class JournalWriterR20642(JournalWriterR17548):
    """
    A class representing a writer of a mathrace journal, version r20642.

    This version added bonus and superbonus race codes.

    Parameters
    ----------
    journal_stream
        The I/O stream that writes the journal to be read by mathrace or simdis.
        The I/O stream is typically generated by open().
    """

    # Race setup codes
    BONUS_DEFINITION = JournalReaderR20642.BONUS_DEFINITION
    """: str: The race setup code associated to bonus definition."""
    SUPERBONUS_DEFINITION = JournalReaderR20642.SUPERBONUS_DEFINITION
    """: str: The race setup code associated to superbonus definition."""

    def _write_race_definition_section(self, turing_dict: TuringDict) -> None:
        """Write the race definition section, including two further lines for bonus and superbonus definition."""
        # Write the section as in previous versions
        super()._write_race_definition_section(turing_dict)

        # Write next the bonus and superbonus definition
        for (code, code_name, turing_key) in (
            (self.BONUS_DEFINITION, "bonus", "fixed_bonus"),
            (self.SUPERBONUS_DEFINITION, "superbonus", "super_mega_bonus")
        ):
            line = self._store_bonus_or_superbonus_definition_line("", turing_dict, code, code_name, turing_key)
            self._write_line(line)

    def _store_bonus_or_superbonus_definition_line(
        self, line: str, turing_dict: TuringDict, code: str, code_name: str, turing_key: str
    ) -> str:
        """Store the bonus or superbonus definition line."""
        assert line == ""
        turing_values = turing_dict[turing_key].split(",")
        return (
            f'--- {code} {len(turing_values)} {" ".join(turing_values)} '
            f"definizione dei {len(turing_values)} livelli di {code_name}"
        )


class JournalWriterR20644(JournalWriterR20642):
    """
    A class representing a writer of a mathrace journal, version r20644.

    This version prints human readable timestamps.

    Parameters
    ----------
    journal_stream
        The I/O stream that writes the journal to be read by mathrace or simdis.
        The I/O stream is typically generated by open().
    """

    def _convert_datetime_to_timestamp(self, datetime_str: str, strict: bool, turing_dict: TuringDict) -> str:
        """
        Convert a date and time into a timestamp.

        This version uses human readable timestamps.
        """
        race_start = datetime.datetime.fromisoformat(turing_dict["inizio"])
        event = datetime.datetime.fromisoformat(datetime_str)
        self._update_last_event_datetime_and_check_events_correctly_sorted(event, strict)
        timedelta = event - race_start
        s = timedelta.seconds
        ms = int(timedelta.microseconds / 1000)
        return f"{s // 3600:02}:{s % 3600 // 60:02}:{s % 60:02}.{ms:03}"


class JournalWriterR25013(JournalWriterR20644):
    """
    A class representing a writer of a mathrace journal, version r25013.

    This version added an extra field to the question definition, but with a placeholder value

    Parameters
    ----------
    journal_stream
        The I/O stream that writes the journal to be read by mathrace or simdis.
        The I/O stream is typically generated by open().
    """

    def _store_question_definition_line(self, line: str, turing_dict: TuringDict, question_id: int) -> str:
        """
        Store a question definition line.

        This method postprocesses the parent implementation due to the following changes:
        * a placeholder of the exact answer has been added in the specifications
        * the comment has been simplified, dropping the "punteggio iniziale" part
        """
        line = super()._store_question_definition_line(line, turing_dict, question_id)
        line, _ = line.split(" punteggio iniziale")
        return line.replace(" quesito ", " 0000 quesito ")


def journal_writer(journal_stream: typing.TextIO, journal_version: str) -> AbstractJournalWriter:
    """
    Write a mathrace journal.

    Parameters
    ----------
    journal_stream
        The I/O stream that writes the journal to be read by mathrace or simdis.
        The I/O stream is typically generated by open().
    journal_version
        The version of the mathrace journal to be written.
    """
    available_versions = list_journal_versions()
    if journal_version not in available_versions:
        raise RuntimeError(f"{journal_version} is not among the available versions")
    journal_writer_class = getattr(sys.modules[__name__], f"JournalWriter{journal_version.capitalize()}")
    return journal_writer_class(journal_stream)  # type: ignore[no-any-return]


if __name__ == "__main__":
    parser = argparse.ArgumentParser()
    input_group = parser.add_mutually_exclusive_group(required=True)
    input_group.add_argument("-i", "--input-file", type=str, default=None, help="Path of the input json file")
    input_group.add_argument(
        "-d", "--download", type=int, default=None, help="Primary key of the turing race to download")
    parser.add_argument("-o", "--output-file", type=str, required=True, help="Path of the output journal file")
    parser.add_argument("-v", "--journal-version", type=str, required=True, help="Version of the output journal file")
    args = parser.parse_args()

    if args.download is not None:  # pragma: no cover
        # This import requires turing to be available, and thus cannot be moved to the common section.
        # We skip coverage testing of this part because we cannot cover this in unit tests, since they
        # cannot interact with turing. Testing this entrypoint is delayed to integration testing.
        import django
        django.setup()

        import engine.models
        turing_dict = engine.models.Gara.objects.get(pk=args.download).to_dict()
    else:
        with open(args.input_file) as json_stream:
            turing_dict = json.load(json_stream)

    with journal_writer(open(args.output_file, "w"), args.journal_version) as journal_stream:
        journal_stream.write(turing_dict)
